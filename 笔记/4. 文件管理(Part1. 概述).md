# 文件管理

# <font color='cornflowerblue'>1. 文件系统: 信息的组织/存储/访问</font>

> ## <font color='cornflowerblue'>1.1. 文件</font>
>
> > ### <font color='cornflowerblue'>1.1.1. 文件的概念</font>
> >
> > > :one:文件的含义：具有一定功能的程序/数据集合，通过文件名(用户访问接口)访问
> > >
> > > :two:文件逻辑分类
> > >
> > > 1. 流文件：中是指文件内信息不再划分单位，只是一串字符流，如exe文件
> > >
> > > 2. 记录文件：按逻辑把文件独立划分位多个信息单位(aka记录，可定长/不定长)，每个记录都有数据项
> > >
> > > :two:文件的组成结构
> > >
> > > 1. 数据项：基本数据项(文件系统中最小/不可分的原子数据单位)+组合数据项(多个基本数据项)
> > > 2. 记录：描述对象某方面的属性
> > > 3. 文件：创建者定义的有关数据项集合，分为有结构/记录式文件+无结构/流式文件
> > >
> > > 举个例子：张三(基本数据项)→张三+18岁(组合数据项)→张三的所有有关属性(记录)→有结构文件(张三李四王五构成的学生信息文件)
> >
> > ### <font color='cornflowerblue'>1.1.2. 文件的属性</font>
> >
> > > :one:内容：名称(唯一)+标识符+文件类型+文件位置+其他(文件大小/建立时间/用户标识)
> > >
> > > PS1: 标识符——OS层面文件的唯一标签，对用户透明
> > >
> > > PS2: 文件位置——指向文件的指针
> > >
> > > :two:属性信息，放在目录中，存储在硬盘中
> >
> > ### <font color='cornflowerblue'>1.1.3. 文件的分类</font>
> >
> > > :one:按用途：系统文件(只允许用户调用)+库文件(只允许用户调用)+用户文件(所有者/授权用户访问)
> > >
> > > :two:按保护级别：只读+读写+执行文件(读/写/执行是三种分立的操作)+不保护文件(随你怎么搞)
> > >
> > > :three:按流向：输入文件(如光盘/键盘中的文件)+输出文件(如打印机上的文件)+IO文件(磁盘)
> > >
> > > :four:按数据形式：源文件(你写的代码文本&数据)+目标文件(源文件编译后)+可执行文件(编译后再链接)
> >
> > ### <font color='cornflowerblue'>1.1.4. 文件的操作</font>
> >
> > > #### <font color='cornflowerblue'>1.1.4.1. 基本操作</font>
> > >
> > > > :one:创建文件：分配空间+目录中建立目录项+建立新的FCB，返回一个文件描述符
> > > >
> > > > :two:删除文件：先删除目录项+回收存储空间
> > > >
> > > > :three:读/写：查找目录→找到指定目录项→得到被读/要写文件的外存地址(指针)→开始读写
> > > >
> > > > :four:截断文件：将文件缩减到指定大小，但保留文件属性
> > > >
> > > > :five:设置文件读写位置：其实就是调整文件指针，让读写不再从头开始
> > >
> > > #### <font color='cornflowerblue'>1.1.4.2. 打开/关闭文件</font>
> > >
> > > > :one:打开文件
> > > >
> > > > 1. OS把文件属性复制到内存，给用户返回一个索引
> > > > 2. 用户通过这个索引向OS请求操作(打开)这个文件
> > > >
> > > > :two:关闭文件
> > > >
> > > > 1. 撤销之前建立的索引信息，切断用户与该文件的联系
> > > > 2. 若文件打开期间修改了，则将其写回外存
>
> ## <font color='cornflowerblue'>1.2. 文件的逻辑结构：用户对文件的组织</font>
>
> > ### <font color='cornflowerblue'>1.2.1. 概述</font>
> >
> > > :one:含义：用户所观察到&处理的文件组织形式
> > >
> > > :two:分类：有结构的记录文件(顺序/索引/索引顺序)+无结构的流文件
> > >
> > > :three:文件访问方式
> > >
> > > 1. 顺序访问：按文件逻辑顺序依次存取
> > > 2. 随机存取：根据记录编号直接存取文件中的任意一个记录(可忽略前面的)
> >
> > ### <font color='cornflowerblue'>1.2.2. 有结构文件分类：由OS/程序决定</font>
> >
> > > #### <font color='cornflowerblue'>1.2.2.1. 顺序文件/连续结构</font>
> > >
> > > > :one:含义：将逻辑文件信息连续存放
> > > >
> > > > :two:分类：定成/不定长(记录长度是否固定)+串结构(记录顺序不按关键字排)/顺序结构(按关键字)
> > > >
> > > > :three:优缺点：<font color="red">常用于批量记录读取</font> ，访问某个记录请求性能不佳，会有碎片/无法动态扩充
> > >
> > > #### <font color='cornflowerblue'>1.2.2.2. 索引文件(好比一个目录)</font>
> > >
> > > > :one:索引表：
> > > >
> > > > 1.  存储逻辑文件记录信息的表，其本身就是一个定长文件
> > > > 2. 每个表目指出一个文件记录在逻辑文件中的位置+长度
> > > >
> > > > :two:索引文件：索引表+逻辑文件
> > > >
> > > > :three:优缺点：随机访问(而不是从头开始)/删除修改添加高效；索引表本身占空间/查找策略影响大
> > >
> > > #### <font color='cornflowerblue'>1.2.2.3. 索引顺序文件</font>
> > >
> > > > :one:含义：将顺序文件中所有记录分组，每组第一个记录在索引表有索引项(关键字+该记录的指针)
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/OfEKmQFd8y2s5nZ.png" alt="image-20231111161111346" style="zoom: 33%;" /> 
> > > >
> > > > :two:检索操作：根据关键字检索索引表→找到组中第一个记录→顺序查找改组直到找到记录
> > > >
> > > > :three:优缺点：存取快，担任有额外存储开销(索引表)
> > >
> > > #### <font color='orange'>1.2.2.4. 直接文件(散列HASH文件)</font>
> > >
> > > > :one:直接文件：由关键字值找到记录的物理地址
> > > >
> > > > :two:散列文件：典型直接文件，关键字$\xrightarrow{HASH函数}$物理地址，存取快但是有冲突
>
> ## <font color='cornflowerblue'>1.3. 物理结构：文件在外存的存储结构</font>
>
> > ### <font color='cornflowerblue'>1.3.1. 概述</font>
> >
> > > :one:用户按逻辑结构使用文件$\xleftrightarrow{转换}$文件系统按物理结构管理文件
> > >
> > > :two:含义：**文件在外存的存放组织形式**
> > >
> > > :three:物理结构的类型：取决于外存方式——连续/链接/缩引分配$\xleftrightarrow{}$连续/链接/缩引结构
> > >
> > > :four:文件存取方式：取决于存储设备特性(磁带是顺序存取，磁盘是直接存取)
> > >
> > > :five:物理块与逻辑记录
> > >
> > > 1. 物理块大小固定，逻辑记录大小可变，一个逻辑记录可只占物理块一部分也可跨越多个物理块
> > > 2. 逻辑块：OS会将文件信息分为与物理块大小相等的逻辑块
> >
> > ### <font color='cornflowerblue'>1.3.2. 连续/链接/缩引分配：见2.3. 文件(在存储器的)实现</font>
> >
> ## <font color='cornflowerblue'>1.4. 目录结构</font>
>
> > ### <font color='cornflowerblue'>1.4.1. 文件控制块(FCB)</font>
> >
> > > :one:文件=FCB+文件体
> > >
> > > :two:含义：用于描述和控制文件的数据结构
> > >
> > > :three:内容：至少有文件名+文件物理地址，此外还有——
> > >
> > > 1. 文件结构：物理的(顺序/索引/索引)，逻辑的(记录/流)
> > > 2. 文件物理位置：存放设备名+存储位置+文件长度
> > > 3. 存取控制信息：存取权限，分为文件主or其他用户
> > > 4. 管理信息：文件建立/上次存取日期，当前使用状态，共享计数
> >
> > ### <font color='orange'>1.4.2. 索引结点</font>
> >
> > > :one:含义：将文件名和文件描述分开→文件名+索引结点(包含文件描述)
> > >
> > > :two:存储特点：索引结点在外存，文件名+索引结点指针在内存(FCB)
> > >
> > > :three:磁盘索引结点内容
> > >
> > > 文件的：主标识+类型+存取权限+物理地址+长度+链接计数+存取时间
> > >
> > > 1. 文件主标识：标识了文件大小/小组的标识符
> > > 2. 文件链接计数：文件系统中指向该文件名的指针数
> > >
> > > :four:内存索引结点：打开文件时，磁盘索引结点$\xrightarrow{复制}$内存索引结点，有如下新增内容
> > >
> > > 1. 索引结点编号：标识内存索引结点
> > > 2. 状态：标识该节点是否上锁/修改
> > > 3. 访问计数：正在访问该文件的进程数
> > > 4. 逻辑设备号：文件所在文件系统的逻辑设备号
> > > 5. 链接指针：指向空链表/散列队列的指针
> >
> > ### <font color='cornflowerblue'>1.4.3. 目录文件&文件目录</font>
> >
> > > :one:文件目录：FCB的有序集合
> > >
> > > 1. 用途：检索文件，实现按名存取，防止冲突 
> > >
> > > 2. 目录项：就是FCB
> > > 3. 目录结构会影响到：文件存取速度/共享性/安全性
> > >
> > > :two:目录文件：文件目录以文件形式保存在外存，这个文件就叫目录文件
> > >
> > > :three:目录操作：建立/寻找/删除一个文件，列出目录列表，重命名文件，遍历文件系统
> > >
> > ### <font color='cornflowerblue'>1.4.4. 目录类型</font>
> >
> > > #### <font color='cornflowerblue'>1.4.4.1. 单级目录结构：仅一表，每个文件占一表项</font>
> > >
> > > > <img src="https://s2.loli.net/2023/11/11/oFqAUQw27IxJPkN.png" alt="image-20211222195413258" style="zoom:50%;" /> 
> > > >
> > > > :one:动态操作
> > > >
> > > > 1. 建立文件：验证不重名后→找出一个空表目然后将信息填入
> > > > 2. 删除文件：找到对应目录项→找到物理地址→回收物理空间→回收目录项
> > > > 3. 访问文件：检索到文件名→找出物理地址→然后操作文件
> > > >
> > > > :two:缺点：只有一个目录，不允许文件重名，查找慢
> > >
> > > #### <font color='cornflowerblue'>1.4.4.2. 二级目录</font>
> > >
> > > > :one:结构：主文件目录+用户文件目录
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/EHiQcBzeh79Grd5.png" alt="image-20211222195549196" style="zoom:60%;" /> 
> > > >
> > > > 1. 主文件目录MFD：给出用户名+用户子目录指针
> > > > 2. 用户子目录UFD：给出用户所有文件的FCB
> > > >
> > > > :two:动态操作
> > > >
> > > > 1. 访问：主目录中查找用户名→进入用户目录查找文件名→得到物理地址
> > > > 2. 新用户建立文件：主目录中建立表目→给新用户目录分配空间→用户目录中添加表目→填入信息
> > > >
> > > > 3. 删除：直接删用户目录的目录项，用户目录为空就把主目录对应项删除
> > > >
> > > > :five:优劣：文件可重名，查找块，但灵活性差，不利于共享
> > >
> > > #### <font color='cornflowerblue'>1.4.4.3. 树形(多级)目录结构</font>
> > >
> > > > <img src="https://s2.loli.net/2023/11/11/BMbwRZ9DVSkyuNU.png" alt="image-20211222195800206" style="zoom:50%;" />  
> > > >
> > > > :one:结构：根目录=第一级的目录，非叶结点=均为目录文件(子目录)，叶=文件(每个文件都有唯一内部标识)
> > > >
> > > > :two:有关概念
> > > >
> > > > 1. 路径名：一个字符串，文件的唯一标识，按照`\`级联，分文绝对(根目录开始)+相对目录
> > > >
> > > > 2. 当前目录(工作目录)：选取某目录为当前目录，进程访问文件都是以这个目录为对照
> > > >
> > > >    PS: 某目录的上一级用`..`标识
> > > >
> > > > :three:优劣：可重名/检索快/有利于分类，查找文件要多次访问目录文件(在外存)
> > >
> > > #### <font color='cornflowerblue'>1.4.4.4. (无环)图形目录：相比树形更便于共享</font>
> > >
> > > > <img src="https://s2.loli.net/2023/11/11/LGCrPFHXT5Ro1Bj.png" alt="image-20231030215013322" style="zoom:67%;" /> 
> > > >
> > > > :one:结构：树形目录+指向同一结点的有向边
> > > >
> > > > :two:共享计数器：
> > > >
> > > > 1. 向该节点增/减共享链时计数器+1/-1，同时增/减指针
> > > > 2. 当共享计数器为0时结点才算真正删除，删除文件本身
> >
> > ### 1.4.5. 文件目录改进：分解FCB为两部分
> >
> > > :one:符号文件目录：文件名+文件内部标识→树状结构，按文件名排序
> > >
> > > :two:基本文件目录：其余文件说明信息→线性结构，按文件内部标识排序
> > >
> > > 可以加快检索
>
> ## <font color='cornflowerblue'>1.5. 文件共享：不同用户使用一个文件</font>
>
> > 核心问题：如何实现共享+共享用户的存取控制
> >
> > ### <font color='cornflowerblue'>1.5.1. 基于索引结点的共享(硬链接)</font>
> >
> > > :one:两个/多个目录项指向相同索引结点
> > >
> > > :two:索引结点有一计数器，统计其对应目录项个数(为1时才可删除节点，大于1时只减1)
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231031001337259.png" alt="image-20231031001337259" style="zoom:67%;" /> 
> >
> > ### <font color='cornflowerblue'>1.5.2. 利用符号链实现文件共享(软链接)</font>
> >
> > > <img src="https://s2.loli.net/2023/11/11/FR1iuBD2abVYH5e.png" alt="image-20231031001502707" style="zoom:67%;" /> 
> > >
> > > :one:符号链接(link类型文件)：包含被链接(共享)文件的**路径名**
> > >
> > > :two:链接和指针：文件拥有者才拥有指针+其他用户路径名，共享给的用户只拥有链接(路径名)
> > >
> > > :three:动态操作：将C的文件，共享给用户
> > >
> > > 1. 共享：B目录中，建立符号链接指向文件 C
> > >
> > > 2. 访问：检索目录，若检索到的是链接，OS自动忽略
>
> ## <font color='orange'>1.6. 文件保护</font>
>
> > :one:限制文件访问类型：读/写/执行/添加/删除/列出属性/重命名/复制/粘贴
> >
> > :two:针对不同用户访问控制
> >
> > 1. 含义：不同权限用户访问同一文件，采取不同访问类型
> >
> > 2. 方式：访问控制矩阵/访问控制表/用户权限表(用数据结构记录用户的操作权限)+口令密码

# <font color='cornflowerblue'>2. 文件系统的实现</font>

> ## <font color='cornflowerblue'>2.1. 文件系统概述</font>
>
> > ### <font color='cornflowerblue'>2.1.1. 文件系统概念</font>
> >
> > > :one:定义：OS中，(以文件方式)管理软件资源的软件+被管理的文件+被管理的数据结构
> > >
> > > :two:文件系统的作用
> > >
> > > 1. OS角度的文件系统：**对存储文件的空间**组织/分配/回收，**对文件**存储/检索/共享/保护
> > >
> > > 2. 用户角度的文件系统：实现按名存取(用户知道文件名就可以获取文件信息)
> >
> > ### <font color='cornflowerblue'>2.1.2. 层次结构</font>
> >
> > > <img src="https://s2.loli.net/2023/11/11/PnwOjm7QteNY4rU.png" alt="image-20231031113206475" style="zoom:67%;" />  
> > >
> > > :one:用户接口：图形窗口/命令行→连接现实与虚拟，用户通过用户接口向OS发出文件操作命令
> > >
> > > :two:文件目录系统：查找目录，找到文件F索引信息
> > >
> > > :three:存取控制验证：即使有索引信息，也要看你有无访问权
> > >
> > > :four:逻辑文件系统与文件信息缓冲区：确定拥有访问权后，先找到逻辑地址
> > >
> > > :five:物理文件系统：再由逻辑地址找到物理地址，这一层分为外存分配管理+设备管理
>
> ## <font color='orange'>2.2. 目录的实现</font>
>
> > :one:线性表：按顺序存放文件信息(文件名+数据块)，创建删除文件就是线性表的插入和删除，创建是还要遍历检查文件是否已存在(因此低效)
> >
> > :two:散列表：(查找/删除时)将HASH函数将文件名转化为数字，用这个数字找到文件信息位置。但需要一个好的冲突解决策略
>
> ## <font color='cornflowerblue'>2.3. 文件在存储器的实现(文件的物理结构)</font>
>
> > ### <font color='cornflowerblue'>2.3.1. 外存分配方式: 如何为文件分配磁盘</font>
> >
> > > #### <font color='cornflowerblue'>2.3.1.1. 顺序分配：文件分配连续的磁盘区域</font>
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231031124445960.png" alt="image-20231031124445960" style="zoom: 50%;" /> 
> > > >
> > > > :one:文件创建过程：用户进程说明文件所需空间，OS查找空闲区管理表，若有足够空间就为文件分配，否则等待
> > > >
> > > > :two:结构：逻辑相邻可以是物理相邻
> > > >
> > > > :three:优劣：查找快，但是会产生外碎片，不适合文件大小动态变化
> > >
> > > #### <font color='cornflowerblue'>2.3.1.2.链接分配</font>
> > >
> > > > <img src="https://s2.loli.net/2023/11/11/rojeH6BPNZdimTI.png" alt="image-20231031130544970" style="zoom:60%;" /> 
> > > >
> > > > :one:隐式链接：
> > > >
> > > > 1. 含义：文件信息再若干不连续块中，每个块都指向文件的下一块，读文件只需找到第一块
> > > > 2. 缺点：<mark>存取速度慢(不适于随机存取)</mark>，可靠性差(一个指针烂了后面都没用了)
> > > >
> > > > :two:显式连接：所有指针被放在**文件分配表FAT**(整个磁盘只有一张)，列出了所有块及其位置。缺点是仍需从表顶开始找
> > >
> > > #### <font color='cornflowerblue'>2.3.1.3. 索引分配</font>
> > >
> > > >  <img src="https://s2.loli.net/2023/11/11/NYsicdgPxLntw3e.png" alt="image-20211111154450144" style="zoom: 50%;" /> 
> > > >
> > > > :one:结构：每个文件分配一个索引块，块中放索引表，表中每个表项分给该文件一个物理块
> > > >
> > > > PS：索引表——本质上是磁盘块地址数组，其中第i个条目指向文件第i块
> > > >
> > > > :two:优点：能够随机存取，无外碎片
> > > >
> > > > :three:缺点：索引块占空间(其大小也很重要)，存取需要两次访问(但可在访问文件前就把索引表调入内存)
> > > >
> > > > :four:多级索引表：如果文件很大索引表也会很大，大到超过一块时，可以把索引表当作文件再为其建立索引表
> > >
> > > #### <font color='cornflowerblue'>2.3.1.4. 番外：多级索引分配补档</font>
> > >
> > > > :one:单级索引分配：文件名为test，索引表放在19块中，索引表指出的文件结构(块序)为9,16,1,10
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/Cwut59FTHqzZg8s.png" alt="image-20231031153326763" style="zoom:67%;" /> 
> > > >
> > > > :two:两级索引分配：文件名test，索引到主索引的块号(每块含有二级索引块号)，又索引到第二级索引块号(每块包含文件块号序列)，索引到文件块号
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/Lku35Hc7yOtGRIr.png" alt="image-20231031153834804" style="zoom:67%;" /> 
> > > >
> > > > :three:混合索引分配：假设每个盘块大小4K
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/wPAQTtcjDy6SO9i.png" alt="image-20231031155321772" style="zoom:67%;" /> 
> > > >
> > > > 1. 直接地址：主要是为提高检索速度，此处有10个直接地址项，可索引10块共40K地址。文件小于40K时直接到这里来
> > > >
> > > > 2. 一次间接地址：就是一级索引分配，其一次可索引1K个盘块，每块4KB，故允许文件长4MB
> > > >
> > > >    为什么是1K呢，因为一个表项4B，一块4KB，所以一块中就有4K个表项，一个表项索引到一块
> > > >
> > > > 3. 二次间接地址：两级索引分配，索引一次1K块，每块又索引1K块，总大小4MB*1K=4GB
> > > >
> > > > 4. 三次间接寻址：以此类推是4TB
> >
> > ### <font color='cornflowerblue'>2.3.2. (空闲)文件存储空间管理</font>
> >
> > > #### <font color='cornflowerblue'>2.3.2.1. 空闲文件表法</font>
> > >
> > > > :one:空闲文件/空白文件/自由文件：存储设备的一个连续空闲区
> > > >
> > > > :two:空闲盘块表：一个空闲文件占据一表项，表项包含第一空闲块号+空闲块号数+物理块号
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/vUdJBMHZOoNkDif.png" alt="image-20231031165117594" style="zoom: 50%;" /> 
> > > >
> > > > :three:动态操作：
> > > >
> > > > 1. 请求存储空间：扫描空闲目录然后请求，请求=空闲直接分配，请求<空闲则留下空余项并修改表项，请求>空闲就不请求
> > > >
> > > > 2. 撤销文件：扫描空闲目录，将释放空间的第一个物理块号填到表中
> > > >
> > > >    释放块与其他空闲块相邻则直接合并
> > >
> > > #### <font color='cornflowerblue'>2.3.2.2. 空闲块链表法</font>
> > >
> > > > :one:概述：将所有空闲块连接成一个链表+一个头指针
> > > >
> > > > :two:动态操作
> > > >
> > > > 1. 建立文件：从链首依次取下几个空闲块给文件
> > > > 2. 撤销文件/回收存储空间：将要回收的空闲块依次链接入空闲块链表
> > > >
> > > > :three:空闲盘区链：
> > > >
> > > > 1. 将链表元素从空闲盘块改为空闲盘区
> > > > 2. 每盘区有：若干空闲盘块+指向下一盘区指针+本盘区大小指示
> > >
> > > #### <font color='cornflowerblue'>2.3.2.3. 位视图法</font>
> > >
> > > > :one:概述：文件存储器在主存中建立一张表，每位都对应一物理块，1=已分配，0=空闲
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/iU3LNkat815MRJr.png" alt="image-20231031172855185" style="zoom:67%;" /> 
> > > >
> > > > :two:动态操作：请求分配时OS先要扫描这张表，找出一组0，得到其盘号，然后改为1；回收正好相反
> > >
> > > #### <font color='orange'>2.3.2.4. 成组链接法(UNIX)</font>
> > >
> > > > :one:基本结构
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/GCuqJrZhNBWUycd.png" alt="image-20231101141812714" style="zoom:67%;" /> 
> > > >
> > > > 1. 将所有空闲块，100块一组分很多组
> > > > 2. 每组需要记录两个数据：组中块数，所有块的编号。这两个数据放在前一组第一块中
> > > > 3. 第一块的这两个数据放在超级块中
> > > > 4. 总体结构：每组第一块链接成链表，组内多块构成堆栈
> > > >
> > > > :two:分配空闲盘块的方法
> > > >
> > > > 1. OS要为文件分配空闲块，先检查第一组中的块数
> > > > 2. 若第一组块数>1，则超级块中记录的空闲块数-1，第一组中栈顶的块分配给文件
> > > > 3. 重复2的操作，直到第一组中只剩一块了，这一块是来记录下一组的块号和块数的
> > > > 4. 则将第二组的信息读入超级块，然后继续分配
> > > > 5. 一直读到最后一组，栈顶盘块有结束标记0，代表所有块都用完了，停止分配
> > > >
> > > > :three:空闲盘块的回收
> > > >
> > > > 1. 若一组中不足100块，则直接把回收的块塞进去，然后超级块中放入该块号&空闲块数+1
> > > > 2. 若一组已经100块了，则先将第一组的块号+块数写入回收块
> > > > 3. 由此这个回收块就变成了新的第一组了(一组仅这一块)
> > > > 4. 最后跟新超级块，块数变为1，设置块号为回收块的块号
