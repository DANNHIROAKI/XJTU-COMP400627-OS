# xv6-labs：lab 4

### 作业内容
#### 实验背景
在本次实验中，你将向xv6文件系统增加支持大文件的功能。

在编写代码之前，你应该阅读xv6书籍中的“第8章：文件系统”并研究相关的代码。

目前 xv6 文件限制为 268 个块或 268*BSIZE 字节（xv6 中 BSIZE 为 1024）。这个限制来自于一个xv6 inode包含12个“直接”块号和一个“单间接”块号，这是指一个块最多可以容纳256个块号，总共12+256=268块。

bigfile命令创建它可以创建的最长文件，并报告该大小：
```
$ bigfile
..
wrote 268 blocks
bigfile: file is too small
$
```

mkfs程序创建xv6文件系统磁盘映像并确定文件系统总共拥有多少块；这个大小由'kernel/param.h'中的FSSIZE控制。源码中初始的FSSIZE被设置为2000块，在本次实验中，请将文件系统中的FSSIZE被设置为200,000块。设置之后，你应该从'mkfs/mkfs'的'make'输出中看到以下输出：
nmeta 70（引导块、超级块、日志块30，inode块13，位图块25）块199930 总共200000
这一行描述了'mkfs/mkfs'构建的文件系统：它有70个元数据块（用于描述文件系统的块）和199,930个数据块，总计200,000块。
如果在实验过程中的任何时候你发现自己需要从头开始重建文件系统，你可以运行'make clean'，它会强制'make'重新构建'fs.img'。

#### 实验内容：增加支持大文件的功能 （🍰🍰🍰🍰）
在本次实验作业中，你需要增加 xv6 文件系统支持的单个文件大小的上限。你需要更改 xv6 文件系统代码以支持每个 inode 中的“双间接”块，其中包含 256 个单间接块地址，每个块最多可包含 256 个数据块地址。因此对xv6的修改使得一个文件最多可以包含 65803 个块，或 256*256+256+11 个块（11 而不是 12，因为我们将牺牲双间接块的直接块号之一） 。

修改'bmap()'以实现双重间接块，除了直接块和单一间接块。为了为新的双重间接块腾出空间，你需要只有11个直接块，而不是12个；你不被允许改变磁盘上inode的大小。ip->addrs[]的前11个元素应该是直接块；第12个元素应该是一个单一间接块（与当前的一样）；第13个元素应该是你的新双重间接块。

##### 提示
+ 确保你理解bmap()。绘制一张图来表示ip->addrs[]、间接块、双重间接块以及它指向的单一间接块之间的关系，以及数据块。确保你理解为什么添加双重间接块会将最大文件大小增加256*256个块（实际上减1，因为你必须减少直接块的数量一个）。
+ 考虑如何使用逻辑块号来索引双重间接块以及它指向的间接块。
+ 如果你更改了NDIRECT的定义，你可能需要更改file.h中struct inode中addrs[]的声明。确保struct inode和struct dinode中的addrs[]数组具有相同数量的元素。
+ 如果你更改了NDIRECT的定义，请确保创建一个新的fs.img，因为mkfs使用NDIRECT来构建文件系统。
+ 如果你的文件系统陷入错误的状态，可能是由于崩溃引起的，请删除fs.img（从容器环境中执行此操作，而不是从xv6中执行）。make将为你构建一个新的干净的文件系统映像。
+ 不要忘记对每个使用bread()读取的块使用brelse()。
+ 你应该根据需要分配间接块和双重间接块，就像原始的bmap()一样。
+ 确保itrunc释放文件的所有块，包括双重间接块。

##### 结果自测
当'bigfile'成功写入并正确读取65803个块时，表明你完成了该实验。
