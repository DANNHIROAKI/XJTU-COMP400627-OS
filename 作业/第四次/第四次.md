# 第四次

# 9.4. 

> 什么是写时复制功能?在什么情况下它的使用是有效的?实现这种功能需要什么硬件支持?
>
> Re：
>
> 1. **什么是写时复制功能?**
>    写时复制是一种避免数据复制的策略，直到这些数据真正需要被修改为止。例如当一个进程想要复制另一个进程的数据时（fork操作），两个进程最初可能共享相同的数据页面，而不是创建数据的独立副本。只有当其中一个进程试图修改数据时，实际的数据副本才会被创建，这样修改就不会影响到其他进程。
>
> 2. **在什么情况下它的使用是有效的?**
>    - **进程创建**: 在UNIX-like系统中，`fork()`系统调用使用COW技术，允许父子进程最初共享相同的物理页面，直到其中一个进程需要修改某个页面时。
>    - **内存管理**: 虚拟化技术、操作系统中的内存页面管理等可以利用COW来优化内存使用。
>    - **数据结构优化**: 某些数据结构，如持久化的数据结构，可以利用COW来减少数据修改时的开销。
>    - **磁盘存储优化**: 一些文件系统，如Btrfs和ZFS，使用COW技术来实现快照和其他功能。
>    
> 3. **实现这种功能需要什么硬件支持?**
>    - **内存管理单元 (MMU)**: MMU可以设置页面权限，使得某个页面只读。当程序尝试写入一个只读页面时，会触发一个硬件异常（例如页错误），操作系统可以捕获这个异常，然后执行真正的复制操作。
>    - **高效的数据复制机制**: 现代CPU通常具有优化的数据移动指令，这些指令可以帮助快速复制数据。
>    - **高速缓存和内存**: 为了使COW效率高，高速的缓存和内存是有益的，因为它们可以减少创建数据副本所需的时间。
>

# 9.8. 

> 考虑下面的页面引用串： 7,2,3,1,2,5,3,4,6,7,7,1,0,5,4,6,2,3,0,1 假设采用3个帧的请求调页，以下置换算法会发生多少次缺页错误? ●LRU置换 ●FIFO置换●最优置换
>
> 1. **LRU置换 (Least Recently Used)**
>
> 我们将使用一个列表来跟踪当前帧中的页面，并按照它们最后使用的时间对页面进行排序。
>
> 引用串：7,2,3,1,2,5,3,4,6,7,7,1,0,5,4,6,2,3,0,1
>
> 开始时，帧是空的。
>
> | 页面引用 | 当前帧    | 缺页错误 |
> | -------- | --------- | -------- |
> | 7        | [7]       | 是       |
> | 2        | [7, 2]    | 是       |
> | 3        | [7, 2, 3] | 是       |
> | 1        | [2, 3, 1] | 是       |
> | 2        | [3, 1, 2] | 是       |
> | 5        | [1, 2, 5] | 是       |
> | 3        | [1, 5, 3] | 是       |
> | 4        | [5, 3, 4] | 是       |
> | 6        | [3, 4, 6] | 是       |
> | 7        | [4, 6, 7] | 是       |
> | 7        | [4, 6, 7] | 否       |
> | 1        | [6, 7, 1] | 是       |
> | 0        | [7, 1, 0] | 是       |
> | 5        | [1, 0, 5] | 是       |
> | 4        | [0, 5, 4] | 是       |
> | 6        | [5, 4, 6] | 是       |
> | 2        | [4, 6, 2] | 是       |
> | 3        | [6, 2, 3] | 是       |
> | 0        | [2, 3, 0] | 是       |
> | 1        | [3, 0, 1] | 是       |
>
> LRU置换中的缺页错误: 18次
>
> 2. **FIFO置换 (First In First Out)**
>
> 我们将使用一个队列来跟踪当前帧中的页面。
>
> 引用串同上。
>
> | 页面引用 | 当前帧    | 缺页错误 |
> | -------- | --------- | -------- |
> | 7        | [7]       | 是       |
> | 2        | [7, 2]    | 是       |
> | 3        | [7, 2, 3] | 是       |
> | 1        | [2, 3, 1] | 是       |
> | 2        | [3, 1, 2] | 是       |
> | 5        | [1, 2, 5] | 是       |
> | 3        | [2, 5, 3] | 是       |
> | 4        | [5, 3, 4] | 是       |
> | 6        | [3, 4, 6] | 是       |
> | 7        | [4, 6, 7] | 是       |
> | 7        | [4, 6, 7] | 否       |
> | 1        | [6, 7, 1] | 是       |
> | 0        | [7, 1, 0] | 是       |
> | 5        | [1, 0, 5] | 是       |
> | 4        | [0, 5, 4] | 是       |
> | 6        | [5, 4, 6] | 是       |
> | 2        | [4, 6, 2] | 是       |
> | 3        | [6, 2, 3] | 是       |
> | 0        | [2, 3, 0] | 是       |
> | 1        | [3, 0, 1] | 是       |
>
> FIFO置换中的缺页错误: 15次
>
> 3. **最优置换 (Optimal Replacement)**
>
> 在最优置换中，当出现缺页错误时，我们会替换在未来最长时间内不会被引用的页面。
>
> 引用串同上。
>
> | 页面引用 | 当前帧    | 缺页错误 |
> | -------- | --------- | -------- |
> | 7        | [7]       | 是       |
> | 2        | [7, 2]    | 是       |
> | 3        | [7, 2, 3] | 是       |
> | 1        | [7, 3, 1] | 是       |
> | 2        | [3, 1, 2] | 是       |
> | 5        | [1, 2, 5] | 是       |
> | 3        | [1, 2, 5] | 否       |
> | 4        | [1, 5, 4] | 是       |
> | 6        | [5, 4, 6] | 是       |
> | 7        | [4, 6, 7] | 是       |
> | 7        | [4, 6, 7] | 否       |
> | 1        | [4, 7, 1] | 是       |
> | 0        | [7, 1, 0] | 是       |
> | 5        | [1, 0, 5] | 是       |
> | 4        | [0, 5, 4] | 是       |
> | 6        | [5, 4, 6] | 是       |
> | 2        | [4, 6, 2] | 是       |
> | 3        | [6, 2, 3] | 是       |
> | 0        | [2, 3, 0] | 是       |
> | 1        | [3, 0, 1] | 是       |
>
> 最优置换中的缺页错误: 14次
>
> 总结：
>
> - LRU置换: 18次缺页错误
> - FIFO置换: 15次缺页错误
> - 最优置换: 14次缺页错误

# 8.1. 

> 指出内部碎片与外部碎片的区别
>
> Re:
>
> 内部碎片和外部碎片都是关于内存管理中由于分配和回收策略导致的空闲内存碎片化的概念。它们的主要区别如下：
>
> 1. **定义**:
>    - **内部碎片**: 当分配给进程的内存块比实际所需的内存大时，其多余的部分就称为内部碎片。这通常在固定大小分区分配方法中发生，如分页和分段。
>    - **外部碎片 : 当内存中有足够的总空闲内存来满足一个进程的需求，但这些空闲内存是分散的，没有一个连续的大块可以分配给该进程时，这种现象称为外部碎片。这通常在动态内存分配方法中发生，如首次适应、最佳适应和最坏适应等算法。
> 2. **出现的位置**:
>    - **内部碎片**: 出现在已分配给某个进程的内存块内部。
>    - **外部碎片**: 出现在两个已分配内存块之间的空闲内存中。
> 3. **成因**:
>    - **内部碎片**: 因为预分配的内存块大小与进程实际所需的内存大小不匹配导致。
>    - **外部碎片**: 由于随着时间的推移，内存中的小块空闲区域增多，它们是由于多次的内存分配和回收造成的。
> 5. **示例**:
>    - **内部碎片**: 假设有一个分页系统，每页大小为4KB。如果一个进程只需要2KB，那么其余的2KB就会浪费，这就是内部碎片。
>    - **外部碎片**: 假设内存中有三个空闲块，每块大小分别为2KB、3KB和4KB。如果有一个进程需要7KB的内存，尽管总的空闲内存为9KB，但由于没有一个连续的7KB块，因此无法满足该进程的需求，这就是外部碎片。
>

# 8.3. 

> ## 解析
> - **首次适应**: 选择第一个满足进程大小的内存分区。
>   - 115KB放入300KB分区，剩余185KB。
>   - 500KB放入600KB分区，剩余100KB。
>   - 358KB放入750KB分区，剩余392KB。
>   - 200KB放入350KB分区，剩余150KB。
>   - 375KB无法放入任何剩余的内存分区。
>
> - **最优适应**: 选择最小的能满足进程大小的内存分区。
>   - 115KB放入125KB分区，剩余10KB。
>   - 500KB放入600KB分区，剩余100KB。
>   - 358KB放入750KB分区，剩余392KB。
>   - 200KB放入200KB分区，没有剩余。
>   - 375KB无法放入任何剩余的内存分区。
>
> - **最差适应**: 选择最大的内存分区。
>   - 115KB放入750KB分区，剩余635KB。
>   - 500KB无法放入任何剩余的内存分区，因为358KB是下一个最大的进程。
>   - 358KB放入600KB分区，剩余242KB。
>   - 200KB放入350KB分区，剩余150KB。
>   - 375KB无法放入375KB分区，因为剩余的375KB是非连续的。
>
> | 内存分区 | 首次适应       | 最优适应       | 最差适应       |
> | -------- | -------------- | -------------- | -------------- |
> | 300KB    | 115KB 剩 185KB | -              | -              |
> | 600KB    | 500KB 剩 100KB | 500KB 剩 100KB | 358KB 剩 242KB |
> | 350KB    | 200KB 剩 150KB | -              | 200KB 剩 150KB |
> | 200KB    | -              | 200KB 剩 0KB   | -              |
> | 750KB    | 358KB 剩 392KB | 358KB 剩 392KB | 115KB 剩 635KB |
> | 125KB    | -              | 115KB 剩 10KB  | -              |
> | 剩余     | -              | -              | 375KB 剩非连续 |
>
> ### 效率排序
> 1. **首次适应**：只有一个进程无法放入。
> 2. **最优适应**：只有一个进程无法放入，但留下的空间比首次适应少。
> 3. **最差适应**：一个进程无法放入，并且留下的空间是非连续的，这可能导致更多的碎
>

# 8.12.

> 1. **3085**:
>    - 逻辑地址除以页大小：3085 ÷ 1024 = 3...13
>    - 页码: 3-1 = 2 （页码从0开始计数）
>    - 偏移量: 13
>
> 2. **42095**:
>    - 42095 ÷ 1024 = 41...111
>    - 页码: 41
>    - 偏移量: 111
>
> 3. **215201**:
>    - 215201 ÷ 1024 = 210...161
>    - 页码: 210
>    - 偏移量: 161
>
> 4. **650000**:
>    - 650000 ÷ 1024 = 634...784
>    - 页码: 634
>    - 偏移量: 784
>
> 5. **2000001**:
>    - 2000001 ÷ 1024 = 1953...129
>    - 页码: 1953
>    - 偏移量: 129
>
> | 地址                        | 页码 | 偏移量 |
> | --------------------------- | ---- | ------ |
> | 3085 = 3 * 1024 + 13        | 2    | 13     |
> | 42095 = 41 * 1024 + 111     | 41   | 111    |
> | 215201 = 210 * 1024 + 161   | 210  | 161    |
> | 650000 = 634 * 1024 + 784   | 634  | 784    |
> | 2000001 = 1953 * 1024 + 129 | 1953 | 129    |

# 8.17. 

> a. 100ns。需要50ns来访问页表条目，再需要50ns来访问数据条目
>
> b. EAT (有效访问时间) = 0.75 * (2ns + 50ns) + 0.25 * 100ns = 64ns