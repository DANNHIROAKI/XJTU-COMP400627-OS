## 5.1

> :one:**资源利用的最大化**
>
> > 1. CPU密集型程序主要消耗的是计算资源，进行大量的计算操作，但不频繁地与外部设备进行通信。因此为这类程序提供更多的 CPU 时间片可以确保它们尽快完成计算任务
> > 2. I/O密集型程序频繁地与外部设备进行交互，但不需要大量的 CPU 时间。如果这类程序持续占据 CPU，那么在等待I/O操作完成时，CPU将被浪费造成效率低下
>
> :two:**系统响应性的提高**
>
> > 1. I/O 密集型程序经常进行IO操作，如果能够及时地为其分配资源，能够提高系统的响应速度
> >
> > 2. 对于需要快速反馈的交互任务(I/O密集型)，通过优先处理这些任务，可以避免用户长时间等待
>
> :three:**充分利用避免资源的浪费**
>
> > 1. 如果调度器不能正确识别程序的特点，可能导致 CPU 在等待 I/O 完成时空闲或I/O 设备在等待 CPU 处理数据时空闲。从而影响系统效率，还可能导致其他任务的延迟
> > 2. 当调度程序能够准确地根据任务的特点分配资源时，它可以同时处理多个任务，从而提高整体的系统吞吐量

## 5.4. 

了解，我将进一步扩充每一点的描述，确保详细性和完整性。

5.3. 
>:one: 每个处理核都有各自的运行队列
>>1. 优点1: 减少资源竞争。独立的队列意味着每个核的任务调度是独立的，从而显著降低了死锁和饥饿现象的风险。
>>2. 优点2: 提高运行效率。每个处理核都能根据自己的队列进行资源预取优化，从而更加高效地执行任务。
>>3. 优点3: 算法简洁。只需针对单一核进行进程调度，不必涉及核间的通信和同步。
>>4. 缺点1: 高资源开销。每个核都需要独立的队列，导致更高的存储和管理成本。
>>5. 缺点2: 同步挑战。在需要跨核同步的场景中，独立的队列可能导致更复杂的同步策略和操作。
>>
>:two: 所有处理核共享一个运行队列
>>1. 优点1: 资源节省。一个共享的队列减少了存储和管理的开销，从而节省成本和降低功耗。
>>2. 优点2: 简化同步。由于所有核共享同一个队列，进行同步操作变得相对简单。
>>3. 缺点1: 资源竞争增加。所有的处理核必须争夺同一个队列中的任务，这可能导致死锁、饥饿或其他竞争条件。
>>4. 缺点2: 优化受限。共享队列限制了针对单一处理核进行特定的优化措施。
>>5. 缺点3: 调度复杂性提高。一个共享队列需要在多个核之间进行信息交互，这可能使得进程调度算法的实现变得更为复杂。

## 5.5. 

> (1)$\alpha=0,\tau_{0}=100ms$时$\tau_{n+1}=\alpha{}t_n+(1-\alpha)\tau_{n}=\tau_n=...=\tau_{0}=100ms$
>
> > 故该算法不考虑实际值，总是会预测下一次的CPU执行时间为100毫秒
>
> (2)$\alpha=0.99,\tau_{0}=10ms$时$\tau_{n+1}=\alpha{}t_n+(1-\alpha)\tau_{n}=0.99t_n+0.01\tau_n\approx{t_n}$
>
> > 故该算法基本只考虑最后一个实际的 CPU 执行时间基本无记忆，对其赋予更高的权重，倾向于预测下次的 CPU执行时间与最后一个实际的CPU 执行时间相似
