## 7.1. 

> 解：
>
> 1. **互斥条件**：每个车辆只能占用一个车道，这就意味着其他车辆无法同时占用该车道
> 2. **占有并等待条件**：每辆车在等待进入交叉口的下一个车道时，已经占用了一个车道
> 3. **非抢占条件**：资源（在这里是车道）在完成任务之前不能被其他进程（车辆）抢占
> 4. **循环等待条件**：在这个示例中，每辆车都在等待前面的车辆移动，以便它可以进入下一个车道。这种情况下，车辆A等待车辆B，车辆B等待车辆C，车辆C等待车辆D，而车辆D又等待车辆A，形成了一个循环等待的情况。
>
> 一个简单的规则是引入交通信号灯或交通管理系统，使得在任何给定的时间内，只有某些方向的车辆可以移动。

## 7.9. 

> 解：
>
> :one: **编号区分法**：根据哲学家的编号区分取筷子的顺序。奇数号哲学家先取左筷子，然后取右筷子；偶数号哲学家则相反。
>
> :two: **资源充足性检查**：在每位哲学家尝试拿筷子前，先检查桌子中央是否有至少两根筷子。只有满足条件时，哲学家才可以尝试进餐，避免因筷子不足导致的死锁。
>
> :three: **回退策略**：如果一个哲学家取到了一根筷子，但是第二根筷子暂时不可用，那么他应立即释放手中的那一根筷子，并过一段时间后再次尝试，降低死锁的机会。
>
> :four: **限制并发进餐人数**：一次只允许最多四个哲学家进餐。因为总共有5根筷子，这样可以确保至少有一个哲学家能够成功取得两根筷子进餐。
>
> :five: **请求顺序制**：建立一个请求队列。哲学家想要进餐时，需先进入队列等待。系统根据队列的顺序为哲学家分配筷子，这样可以避免哲学家们争夺筷子导致的死锁。

## 7.13.

> 解：
>
> 对于每个进程：
>
> P0: (4-2, 2-0, 1-0, 2-1) = 2 2 1 1
> P1: (5-3, 2-1, 5-2, 2-1) = 2 1 3 1
> P2: (2-2, 3-1, 1-0, 6-3) = 0 2 1 3
> P3: (1-1, 4-3, 2-1, 4-2) = 0 1 1 2
> P4: (3-1, 6-4, 6-3, 5-2) = 2 2 3 3
>
> a. 考察安全状态：
>
> 1. 从进程中选择一个`Need`小于或等于`Available`的进程，执行这个进程，然后将这个进程的`Allocation`加回到`Available`。
> 2. 重复步骤1，直到所有进程都已执行。
>
> 以此方法进行，我们可以得到执行顺序：P0, P2, P3, P4, P1。这说明系统是处于安全状态的。
>
> b. 当进程P1请求(1,1,0,0)时，该请求小于其`Need`（2,1,3,1），并且小于当前的`Available`（3,3,2,1）。因此，我们假设分配此请求，并更新`Available`为(2,2,2,1)。然后，我们按照上述银行家算法的安全性检查方法进行，可以得到安全执行序列：P0, P2, P3, P1, P4。因此，P1的请求可以立即被允许。
>
> c. 当进程P4请求(0,0,2,0)时，该请求小于其`Need`（2,2,3,3），但大于当前的`Available`（3,3,2,1）。因此，无法满足P4的请求，所以此请求不能立即被允许。

## 6.9.

> 
>
> 1. `test_and_set(*target)`是一个原子指令，测试`target`的值，如果`target`为0，它就会设置为1，返回旧的值。
> 2. `compare_and_swap(*target, old, new)`也是一个原子指令，比较`target`的值是否为`old`，如果是，它就会将`target`设置为`new`并返回1（表示成功），否则不做任何操作并返回0（表示失败）。
>
> 上述两个指令来实现`acquire`和`release`函数：
>
> ```c
> typedef struct {
>     int available;
> } lock;
> 
> void init(lock *mutex) {
>     mutex->available = 0; // 0表示锁是可用的
> }
> 
> void acquire(lock *mutex) {
>     while (test_and_set(&(mutex->available)) == 1) {
>         // 不断尝试获取锁直到成功
>     }
> }
> 
> void release(lock *mutex) {
>     compare_and_swap(&(mutex->available), 1, 0); // 释放锁
> }
> ```
>
> - `acquire`函数会不断尝试使用`test_and_set`指令获取锁，只有当`mutex->available`为0（表示锁未被持有）时，`test_and_set`才会成功地设置它为1并退出循环。
>   
> - `release`函数简单地使用`compare_and_swap`指令将`mutex->available`从1（锁被持有）设置回到0（锁可用）。 
>

## 6.11.

> 
>
> 1. **用锁的时间很短**：
>     - **自旋锁**：对于短时间的锁定，自旋锁通常更为合适。因为线程只需短暂等待，自旋锁可以避免上下文切换的成本。当预期的等待时间少于上下文切换的时间时，自旋锁通常更有效。
>
> 2. **用锁的时间很长**：
>     - **互斥锁**：当锁持有时间较长时，互斥锁更为合适。在这种情况下，自旋锁可能会浪费大量CPU时间在无效的轮询上，而互斥锁可以使等待的线程进入睡眠状态，从而释放CPU给其他线程使用。
>
> 3. **线程在拥有锁时可能处于睡眠**：
>     - **互斥锁**：如果线程在持有锁的过程中可能会被阻塞或睡眠（例如，等待I/O操作完成），那么应该使用互斥锁。因为在这种情况下，使用自旋锁会导致其他线程在等待锁释放时浪费大量CPU时间。
>
> 自旋锁适合于锁的持有时间短且锁的竞争不激烈的情况，而互斥锁适合于锁的持有时间长或可能伴随线程睡眠的情况。

## 6.19.

> 解：

## PS:

进程get把从读卡机读取的数据放进buffer1；进程copy把buffer1的信息处理后放到buffer2；进程put从buffer2中取数并打印输出。请用PV操作协调上述3个进程的同步关系。

![image-20231020222420676](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231020222420676.png)
