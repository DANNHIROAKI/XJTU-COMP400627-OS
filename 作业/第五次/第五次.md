# 第五次

# 10.9. 

> **单一副本策略**：
>
> 1. **资源节约**：只维护一个文件副本意味着使用的存储空间较少，有助于减少存储成本。
>2. **一致性**：由于只有一个副本，管理文件的版本和一致性变得相对简单。所有用户都访问同一版本，不会出现版本不一致的情况。
> 3. **简化的管理**：不需要同步和合并多个副本，这降低了管理的复杂性。
> 
>**多个副本策略**：
> 
> 1. **可用性**：多个副本提供了高可用性。如果一个副本不可用或损坏，其他副本仍然可以提供服务。
> 2. **性能优化**：分布在不同位置的用户可以选择物理位置最近的副本进行访问，从而减少延迟并提高访问速度。
> 3. **分布式负载**：通过将请求分发到多个副本，可以减少单个服务器或存储系统上的负载。
> 4. **灵活性**：用户可以独立工作在自己的副本上，之后再将更改合并回主文件。

# 10.11. 

> 1. **性能提升**：当用户数量众多时，每个用户拥有自己的文件副本可以降低对中心服务器的负载，从而提高系统的响应速度。
>2. **局部性优化**：当系统分布在不同的地理位置时，每个地点都有文件的本地副本可以减少网络延迟，提供更快的访问速度。
> 3. **容错和可用性**：多个副本可以作为彼此的备份。如果一个副本出现问题或不可访问，用户仍然可以访问其他副本。
>4. **灵活的定制**：用户可以根据自己的需要修改自己的文件副本，而不影响其他用户。

# 11.3.

> 1. **随机访问**：与传统的链接分配不同，FAT允许随机访问文件的任何块，因为所有链接都存储在一个中心表中，不需要从头开始遍历。
>2. **简化的块管理**：FAT提供了一个集中的位置来跟踪所有可用的和已使用的磁盘块，从而简化了块的管理和分配。
> 3. **恢复能力**：由于所有文件的链接都存储在一个中心位置，所以如果文件的某一部分受损，其它部分仍然可以恢复和访问。
>

# 11.7.

> ### a. 如何完成逻辑到物理的地址映射？
>
> 1. **连续分配**：
>    - 逻辑地址是连续的，物理地址也是连续的。
>    - 映射方程：逻辑地址 = 物理地址 / 盘块大小。
>    - 这意味着，如果你知道文件开始的物理地址和逻辑块号，你可以轻松地计算出物理地址。
>
> 2. **链接分配**：
>    - 磁盘上的每个块都有一个指向下一个块的指针。
>    - 设置一个表来为整个磁盘或磁盘分区映射，每个表项的序号与磁盘块号相对应。此表用于存储文件下一个数据块（逻辑地址）所在的磁盘块号。
>
> 3. **索引分配**：
>    - 文件的逻辑地址被保存在索引块中。
>    - 文件前10个逻辑地址直接保持在索引块的盘块号上。
>    - 紧接着的逻辑地址被保存在一级索引中，一级索引可以保存1024个逻辑地址。
>    - 之后是二级索引，可以保存1024 * 1024个逻辑地址。
>    - 最后是三级索引，可以保存1024 * 1024 * 1024个逻辑地址。
>
> ### b. 如果我们当前在逻辑块10，并且想要访问逻辑块4，必须从磁盘读取多少物理块？
>
> 1. **连续分配**：因为物理地址和逻辑地址是连续的，所以我们只需要读取一个物理块
>    
> 2. **链接分配**：从逻辑块10开始，我们必须沿着链回溯，直到找到逻辑块4，所以需要读取4个物理块
>    
> 3. **索引分配**：只需查找索引块，因此只读取2个物理块：一个是索引块，另一个是逻辑块4的数据块
>

# 11.8.

> 1. **直接磁盘块**： 有12个直接指针，每个指针指向8kb的磁盘块。 总大小 = 12 * 8kb = 96kb
> 2. **单间接磁盘块**： 一个指针指向一个8kb的磁盘块，这个磁盘块可以容纳2048个指针（8kb / 4b = 2048），每个指针都指向8kb的数据块。 总大小 = 2048 * 8kb = 16,384kb
> 3. **双间接磁盘块**： 一个指针指向一个8kb的磁盘块，这个磁盘块可以容纳2048个指针，每个指针都指向另一个可以容纳2048个指向8kb数据块的指针的磁盘块。 总大小 = 2048 * 2048 * 8kb = 33,554,432kb
> 4. **三间接磁盘块**： 一个指针指向一个8kb的磁盘块，这个磁盘块可以容纳2048个指针，每个指针指向另一个可以容纳2048个指针的磁盘块，而这些磁盘块又指向可以容纳2048个指向8kb数据块的指针的磁盘块。 总大小 = 2048 * 2048 * 2048 * 8kb = 68,719,476,736kb

# 12.2.

> 1. 与传统的硬盘驱动器（HDD）不同，SSD没有机械部件，如磁头或旋转的磁盘。这意味着SSD无需消耗时间来物理定位磁头到特定的磁盘柱面，从而消除了寻道时间。
> 2. SSD的随机读写速度非常快，几乎与顺序读写速度相当。因此，相对于HDD，在SSD上寻找特定的数据块的时间开销是微不足道的。
> 3. FCFS算法的实现相对简单。因为SSD本身的访问时间已经很短，采用更复杂的调度算法可能不会带来明显的性能提升，反而可能增加不必要的复杂性。
> 4. 为了延长SSD的使用寿命，需要确保其各部分都均匀写入。复杂的调度策略可能导致某些部分的写入次数过多，而FCFS提供了较为均匀的写入模式。
> 5. 复杂的磁盘调度策略可能需要更多的计算和内部管理，这在SSD上可能是不必要的开销。

# 12.3.

> a. **FCFS (First-Come-First-Serve)**:
> 此方法按照请求的先后顺序满足请求。即按照2069,1212,2296,...的顺序。
> - 移动距离 = |2150-2069| + |2069-1212| + ... + |1523-4965| + |4965-3681| = 13011
>
> b. **SSTF (Shortest Seek Time First)**:
> 此方法选择距离当前磁头位置最近的请求。
> - 从2150开始，1618是最近的请求。
> - 从1618开始，1523是最近的请求。
> - 以此类推...
> - 总移动距离 = 7586
>
> c. **SCAN**:
> 磁头从当前位置开始移动到柱面的一个端，然后反转到另一端。
> - 从2150向4999移动，满足2296, 2800, 3681, 4965等请求。
> - 然后从4999向0移动，满足2069, 1618,..., 544等请求。
> - 总移动距离 = 7492
>
> d. **LOOK**:
> 类似于SCAN，但磁头只移动到最后一个请求的位置，而不是柱面的端点。
> - 从2150向3681移动，然后反转至544。
> - 总移动距离 = 7424
>
> e. **C-SCAN (Circular SCAN)**:
> 磁头从当前位置移动到柱面的一个端，然后立即跳到另一端开始移动。
> - 从2150向4999移动，满足所有请求，然后跳到0开始满足到2069的请求。
> - 总移动距离 = 9917
>
> f. **C-LOOK**:
> 类似于C-SCAN，但磁头只移动到最后一个请求的位置，然后立即跳到第一个请求开始移动。
> - 从2150向4965移动，然后跳到544开始满足到2069的请求。
> - 总移动距离 = 9137
>

# 总结4种I/O控制方式的优缺点

> 1. **程序控制I/O**:
>     - **优点**：
>         - 设计简单，理解和实施都很直接。
>         - 对于低带宽或低速设备是合适的。
>     - **缺点**：
>         - CPU要花费大量时间在I/O操作上，尤其是对于高速设备。
>         - 不能充分发挥多任务处理系统的优势。
>
> 2. **中断驱动I/O:
>     - **优点**：
>         - CPU可以在等待I/O操作完成时执行其他任务。
>         - 提高了效率，因为只有在数据准备好时才会中断CPU。
>     - **缺点**：
>         - 增加了系统的复杂性，因为需要处理中断。
>         - 对于非常快速的I/O操作，中断可能会过于频繁，导致系统开销增加。
>
> 3. **直接存储器访问I/O:
>     - **优点**：
>         - CPU不直接参与I/O数据传输，从而释放了CPU来执行其他任务。
>         - 适合高带宽和大量数据的I/O操作。
>     - **缺点**：
>         - 需要额外的DMA控制器硬件。
>         - 可能与系统的其他部分发生资源冲突。
>
> 4. **通道I/O:
>     - **优点**：
>         - 提供专门的处理器来执行I/O操作，进一步减轻了CPU的负担。
>         - 可以并行处理多个I/O操作。
>     - **缺点**：
>         - 增加了硬件的复杂性和成本。
>         - 需要专门的编程和管理技能。
>
