[TOC]

# 第八章 死锁

## 处理死锁的方法

目前处理死锁的方法有以下四种：

> **鸵鸟算法**：视而不见
>
> **预防死锁**：抑制死锁的必要条件
>
> **避免死锁**：在资源的动态分配过程中，用某种方式防止系统进入不安全状态
>
> **检测与解除死锁**：检测出死锁的产生，然后采用某种措施解除

### 鸵鸟算法

忽略这个问题，假装系统中从未出现过死锁。这个方法被大部分的操作系统采用，包括UNIX）鸵鸟策略

### 预防死锁Deadlock Prevention 

抑制死锁的必要条件

**互斥**：共享资源不是必须的，必须保持非共享资源

**占有并等待**：**必须保证进程申请资源的时候没有占有其他资源**

> 要求进程在执行前一次申请全部的资源
>
> 没有资源时，可以申请资源。在申请更多其它资源之前，需要释放已有资源
>
> **利用率低，可能出现饥饿**

**非抢占**：如果一个进程的申请没有实现，它要释放所有占有的资源；抢占的资源放入进程等待资源列表中，只有进程能够重新得到旧的资源和新申请的资源时，才可以重新开始

**循环等待**：将所有的资源类型放入资源列表中，并且要求进程按照资源表申请资源；编号递增申请

死锁预防的副作用：

> 降低设备利用率和吞吐量
>
> 可能有进程饥饿

### 死锁避免

允许进程**动态地**申请资源，系统在进行资源分配之前，先计算资源分配的安全性

若此次分配不会导致系统从**安全状态向不安全状态**转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待。

安全状态是**指系统的一种状态，在此状态下,系统能按某种顺序（例如P1、P2……Pn）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。这个序列（P1、P2…….Pn）称为安全序列。**

若某一时刻不存在一个安全序列，则称系统处于不安全状态。

> 如果一个系统在安全状态，就没有死锁
>
> 如果系统死锁，则处于不安全状态
>
> 如果一个系统处于不安全状态，就有可能死锁
>
> 可以存在多个安全序列

#### 资源分配图算法

**当一种资源只有一个实例**

需求边$P_i->R_j$  代表进程Pi可能会申请资源Ri，表示为虚线

一个进程申请资源的时候，需求边转化为请求边

当资源被进程释放的时候，分配边转化为需求边

系统中的资源必须被事先声明

当一个进程Pi 申请资源Rj时，由循环检测算法来检查:

> 如果把图中的申请边$P_i->R_j$ 转为分配边$R_j -> P_i$ ，图中是否会出现环路，只有不出现环路，才实施资源分配。

#### 银行家算法

```
在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。
```

**当一种资源有多个实例**

当一个进程请求资源，它可能要等待

当一个进程得到所有的资源，它必须在有限的时间释放它们

每一个进程必须事先声明使用的最大量

**数据结构**

n为进程的数目，m为资源类型的数目

Available：如果available[j]=k,那么资源Rj有k个实例有效

Max：如果Max[i,j]=k,那么进程Pi可以最多请求资源Rj的k个实例

Allocation：如果Allocation[i,j]=k,那么进程Pj当前分配了k个资源Rj的实例

Need：如果Need[i,j]=k,那么进程Pi 还需要k个资源Rj的实例

![image-20211026171900404](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211026171900404.png)

**资源请求算法**

设$Request_i$为进程Pi的请求向量，如果$Requset_i[j]==k$,那么进程Pi需要资源类型Rj的实例数量为k，当进程Pi作出在这一资源请求时：

:one: 如果$Requset_i\le Need_i$，转到第2步，否则生成出错条件，这是因为进程$P_i$已经超过了其最大需求。

:two: 如果$Requset_i\le Available$，转到第3步，否则Pi应该等待，因为没有资源可用

:three: 假设系统可以分配给进程Pi请求的资源，并按以下方式修改状态

![image-20211026173833258](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211026173833258.png)

:four: 用安全算法检查系统是否处在安全状态

**安全算法**

![image-20211026174212179](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211026174212179.png)

<img src="https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211222110712565.png" alt="image-20211222110712565" style="zoom: 50%;" />

**举例**

5个进程P0到P4:3个资源类型A(10个实例），B（5个实例），C（7个实例）

<img src="https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211026174521361.png" alt="image-20211026174521361" style="zoom:80%;" />

![image-20211026174805259](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211026174805259.png)

### 死锁检测

检测死锁与恢复策略

#### 每种资源只有一个实例

等待图法——有环就有死锁

#### 每种资源有多个实例

<img src="https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211222110040556.png" alt="image-20211222110040556" style="zoom:50%;float:left" /><img src="https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211222110819324.png" alt="image-20211222110819324" style="zoom:50%;" />

![image-20211222111344136](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211222111344136.png)

### 死锁恢复

**进程终止**

> 终止所有的死锁进程
>
> 一次终止一个进程直到死锁环消失
>
> 选择终止顺序：进程的优先级；进程计算了多少时间，还需要多少时间

**资源抢占**

> 逐步从进程中抢占资源，直到打破死锁
>
> 回退：返回到安全的状态，然后重新开始进程
>
> 饥饿：同一个进程可能总是被选中，包括在回退时

### 

