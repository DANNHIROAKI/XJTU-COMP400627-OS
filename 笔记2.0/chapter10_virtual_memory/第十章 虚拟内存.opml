<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <dateModified></dateModified>
    <ownerName></ownerName>
  </head>
  <body>
<outline text="第十章 虚拟内存管理">
  <outline text="10.1 Background（背景）" _note="如果进程大于内存的容量或内存中同时运行多个进程，使用覆盖和动态加载可以缓解，但是需要程序员的额外工作。&#10;&#10;解决办法：&#10;&#10;&gt; 从物理上扩充内存容量&#10;&gt;&#10;&gt; 从逻辑上扩充内存容量&#10;&#10;常规存储器的特征&#10;&#10;&gt; 一次性： 作业在运行前需要一次性的全部装入内存&#10;&gt;&#10;&gt; 驻留性：作业装入内存后，便一直驻留在内存中，直到作业结束。&#10;&#10;正是由于一次性和驻留性，使得程序中**暂时不用的数据占用了大量的内存空间**，从而需要运行的作业无法装入内存。">
    <outline text="局部性原理" _note="在一段时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域内。">
      <outline text="原因" _note="程序在执行时，除了少部分的转移和过程调用指令外，大多数仍是顺序执行的。&#10;&#10;子程序调用将会使程序的执行由一部分内存区域转至另一部分区域&#10;&#10;程序中存在许多循环结构，循环体中的指令被多次执行。&#10;&#10;程序中还包括许多对数据结构的处理，如对连续的存储空间——数组的访问，往往局限于很小的范围内。">
      </outline>
      <outline text="局部性表现" _note="局部性表现为：">
        <outline text="时间局部性" _note="如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；&#10;&#10;如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。&#10;&#10;产生时间局限性的典型原因是在**程序中存在着大量的循环操作**。">
        </outline>
        <outline text="空间局部性" _note="一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。&#10;即程序在一段时间内所访问的地址，可能集中在一定的范围内，其典型原因是程序是顺序执行的。">
        </outline>
      </outline>
    </outline>
    <outline text="虚拟内存" _note="虚拟内存是一种允许进程部分装入内存就可以执行的技术&#10;&#10;&gt; 局部性原理 : 时间局部性，空间局部性&#10;&gt;&#10;&gt; 只有运行的部分程序需要在内存中&#10;&gt;&#10;&gt; 逻辑地址空间能够比物理地址空间大&#10;&gt;&#10;&gt; 必须允许页面能够被换入和换出">
      <outline text="手段" _note="请求页式、请求段式">
      </outline>
      <outline text="特征" _note="&gt; **离散性**:在内存分配时采用离散的分配方式，是虚拟存储器的最基本的特征。&#10;&gt;&#10;&gt; **多次性**:一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。是虚拟存储器最重要的特征。&#10;&gt;&#10;&gt; **对换性**:作业运行过程中信息在内存和外存的对换区之间换进、换出。&#10;&gt;&#10;&gt; **虚拟性**:**从逻辑上扩充内存容量**，使用户所看到的内存容量远大于实际内存容量。">
      </outline>
      <outline text="好处" _note="&gt; 可在较小的可用内存中执行较大的用户程序&#10;&gt;&#10;&gt; 可在内存中容纳更多程序并发执行&#10;&gt;&#10;&gt; 简化了编程操作， 不影响编程时的程序结构（与覆盖技术比较）&#10;&gt;&#10;&gt; 提供给用户可用的虚拟内存空间通常大于物理内存(real memory)">
      </outline>
      <outline text="需要解决的问题" _note="❓程序部分运行可以吗?&#10;&#10;&gt; 取页--将所需的部分装入内存&#10;&#10;❓发现程序不在内存时,如何将其装入后继续运行?&#10;&#10;&gt; 请求调页—缺页时，产生**缺页中断**，将外存上的页调入内存&#10;&#10;❓ 内存无空间时怎么办?&#10;&#10;&gt; 页面**置换**(换的不是一个进程，而是一个页)--内存不足时，将哪些页换出内存">
      </outline>
    </outline>
  </outline>
  <outline text="10.2 Demand Paging（请求页式）">
    <outline text="页面调入策略">
      <outline text="预调页策略" _note="&gt; 主动的页面调入策略，即把那些预计很快会被访问的程序或数据所在的页面，预先调入内存。&#10;&gt;&#10;&gt; 预测的准确率不高（50%），**主要用于进程的首次调入**。也有的系统将预调页策略用于请求调页">
      </outline>
      <outline text="请求调页策略" _note="&gt; 当进程在运行中发生缺页时，由系统将缺页调入内存。&#10;&gt;&#10;&gt; **目前虚拟存储器系统大多采用此策略。**&#10;&gt;&#10;&gt; 在调页时须花费较大的系统开销，如需频繁启动磁盘I/O。&#10;&#10;❓从何处调入页面&#10;&#10;在虚拟存储系统中，外存（硬盘）被分成两部分:文件区和对换区。对换区（连续分配）的磁盘I/O速度比文件区（离散分配）要高。&#10;&#10;&gt; 1️⃣ 从文件系统中调入页面&#10;&gt;&#10;&gt; 2️⃣ 从交换区中调入页面">
      </outline>
    </outline>
    <outline text="基本概念" _note="请求分页中的硬件支持&#10;&#10;**1）页表机制**&#10;&#10;![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211104150451591.png)&#10;&#10;&gt; **状态位（存在位P）**：用于指示该页是否已调入内存，供程序访问时参考。&#10;&gt;&#10;&gt; **访问字段A**：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。&#10;&gt;&#10;&gt; **修改位M**：表示该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一份副本，因此，若未被修改，在置换该页时就不需将该页写回到外存上，以减少系统的开销和启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本。---&gt;提高性能&#10;&gt;&#10;&gt; **外存地址**：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用。&#10;&#10;**2）缺页中断机制**&#10;&#10;请求分页系统中，每当所要访问的页面不在内存时，便要产生一缺页中断，请求OS将所缺页调入内存。与一般中断的**主要区别在于**：&#10;&#10;&gt; 缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完后检查和处理中断信号。&#10;&gt;&#10;&gt; 缺页中断返回到该指令的开始重新执行该指令，而一般中断返回到该指令的下一条指令执行。&#10;&gt;&#10;&gt; 一条指令在执行期间，可能产生多次缺页中断。&#10;&#10;**3）地址变换机制**&#10;&#10;在每一个页表的表项有一个有效- 无效位相关联，1表示在内存，0表示不内存&#10;&#10;1️⃣ 查找页表来确定此次地址访问是否合法&#10;&#10;2️⃣ 如果不合法,则中止该进程;&#10;否则如果有效但不在内存，即发生了缺页,则需要将其调入内存&#10;&#10;3️⃣ 所需页在外存，找到该页&#10;&#10;4️⃣ 找到一个空闲物理块，启动磁盘,把该页读入内存&#10;&#10;5️⃣读磁盘结束后,修改页表以指出该页已在内存中&#10;&#10;6️⃣ 重新开始执行刚才发生缺页中断的指令,这时它可以访问刚才调入的页">
    </outline>
  </outline>
  <outline text="10.3 请求调页的性能" _note="主要的动作：&#10;&#10;&gt; 处理缺页中断&#10;&gt;&#10;&gt; 从磁盘读入所需的页——最大的时间开销&#10;&gt;&#10;&gt; 重新开始被中断的进程">
    <outline text="缺页率" _note="假定作业Ji共有m页，系统分配给它的主存块为n块，这里m&gt;n。&#10;&#10;如果作业Ji执行过程中总的内存访问次数为A,&#10;成功访问的次数为S，不成功的访问次数为F(产生缺页中断的次数),则:&#10;&#10;&gt; A=S+F&#10;&gt;&#10;&gt; 缺页率: p=F/A">
    </outline>
  </outline>
  <outline text="10.4 页置换" _note="找到内存中没有真正使用的一些页，换出&#10;&#10;需要找出一个缺页数最少的算法&#10;&#10;如果没有空闲帧，需要两个页面传输，一个换出，一个换入。可以通过修改位来降低额外开销。置换实现了逻辑内存和物理内存的划分—在一个较小的物理内存基础之上可以提供一个大的虚拟内存.">
  </outline>
  <outline text="10.5 页置换算法" _note="通过运行一个内存访问的特殊序列（访问序列），计算这个序列的缺页次数&#10;&#10;访问序列是&#10;&#10;&gt; 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5&#10;&gt;&#10;&gt; 7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1">
    <outline text="最佳算法（OPT)" _note="被置换的页将是之后最长时间不被使用的页">
    </outline>
    <outline text="先进先出算法FIFO" _note="FIFO算法可能会产生Belady异常，就是更多的页框相反会产生更多的缺页">
    </outline>
    <outline text="最近最久未使用LRU" _note="使用离过去最近的情况作为不远将来的近似，可以选择最近最少使用的页进行置换。&#10;&#10;LRU选择最长时间没有使用的页。&#10;&#10;实现该算法需要硬件支持，记录物理帧的使用情况，，需要使用到计数器或者栈">
    </outline>
    <outline text="LRU近似算法" _note="没有足够的硬件支持的话，可以使用该算法&#10;&#10;**访问位**：每个位都与一个位相关联，初始值为0，当页是访问页时设置为1&#10;&#10;**二次机会(clock)**&#10;&#10;&gt; 如果将要（以顺时针）交换某页的访问位是1，则&#10;&gt;&#10;&gt; 把访问位设为0&#10;&gt;&#10;&gt; 把页留在内存中&#10;&gt;&#10;&gt; 以同样的规则，替换下一个页&#10;&#10;![](C:\Users\易俊泉\AppData\Roaming\Typora\typora-user-images\image-20211109170122651.png)&#10;&#10;**增强的二次访问**&#10;&#10;不仅考虑页面的使用情况，还考虑置换代价&#10;&#10;选择淘汰页面时，既要是未被访问的，还要是未被修改的页面。&#10;&#10;实现：设置两位&#10;&#10;&gt; 访问位（A）， 修改位（M）&#10;&gt;&#10;&gt; 启动一个进程时，A、M置0&#10;&gt;&#10;&gt; A被定期清零&#10;&#10;内存中的所有页面被分成为四类:&#10;&#10;&gt; 第0类：无访问，无修改(A=0,M=0)&#10;&gt;&#10;&gt; 第1类：无访问，有修改(A=0,M=1)&#10;&gt;&#10;&gt; 第2类：有访问，无修改(A=1,M=0)&#10;&gt;&#10;&gt; 第3类：有访问，有修改(A=1,M=1)&#10;&#10;OS首先寻找第0类页面，将找到的第一个页面淘汰；&#10;&#10;若没找到，则找第1类页面，将找到的第一个页面淘汰，并将扫描过的页面的A位全部置为0；&#10;&#10;若没找到，则指针回到开始位置，将所有的A位置为0。然后重复第一步。">
    </outline>
    <outline text="其他算法" _note="LFU ：最少使用算法：置换计数器值最小的一个页，即访问次数最少的页&#10;&#10;MFU&#10;：最常使用算法，认为：最小计数的页也许刚刚被换入和使用，所以置换计数器值最大的页">
    </outline>
  </outline>
  <outline text="10.6 页框的分配" _note="如何给进程分配一定的空闲内存？&#10;&#10;最少页数&#10;&#10;&gt; 保证进程正常运行所需的最小物理块数&#10;&gt;&#10;&gt; 若系统为某进程所分配的物理块数少于此值时，进程将无法正常运行(频繁发生缺页)&#10;&gt;&#10;&gt; 这个数目取决于指令的格式、功能和寻址方式。&#10;&#10;分配策略&#10;&#10;&gt; 平均分配&#10;&gt;&#10;&gt; &gt; 100个帧，5个进程，每个进程20个帧&#10;&gt;&#10;&gt; 按比例分配&#10;&gt;&#10;&gt; &gt; 根据每个进程的大小来分配&#10;&gt;&#10;&gt; 优先分配&#10;&gt;&#10;&gt; &gt; 根据优先级分配">
    <outline text="全局替换与局部替换" _note="有空闲帧时可以从空闲帧链表中选择一个帧分配，当没有空闲帧可用时，从哪里分配帧？&#10;&#10;&gt; **全局替换**&#10;&gt;&#10;&gt; &gt; 进程在所有的页中选择一个替换页面；一个进程可以从另一个进程中获得页面&#10;&gt;&#10;&gt; **局部替换**&#10;&gt;&#10;&gt; &gt; 每个进程只从属于它自己的页中选择&#10;&#10;局部置换时，分配给每个进程的帧的数量不变&#10;&#10;全局置换时，进程的帧数量会增加，但是无法控制页错误率&#10;&#10;相对而言，全局替换会带来较高的系统吞吐率&#10;&#10;&gt; 固定分配+局部替换&#10;&gt;&#10;&gt; 可变分配＋全局替换&#10;&gt;&#10;&gt; 可变分配+局部替换">
    </outline>
  </outline>
  <outline text="10.7 Thrashing（颠簸）" _note="如果进程分配到的帧数量小于计算机体系结构所要求的最小数量，那么必须暂停进行执行。并将其置换出去，使其所有分配帧空闲。&#10;&#10;为什么？&#10;&#10;如果进程没有这些必需的帧，那么很快会出现缺页，此时需置换某个页，然而，其所有页都在使用，置换出去的页立刻又需要置换进来，因此，会不断的产生缺页。&#10;&#10;**这种频繁的调页行为称作颠簸，也叫抖动。**&#10;&#10;&gt; 一个进程的页面经常换入换出，花在换页上的时间要大于进程执行时间&#10;&#10;抖动:刚被换出的页很快又被访问，需重新调入，导致系统频繁地交换页面，以致大部分CPU时间花费在完成页面置换的工作上。这样会造成**CPU利用率低下**&#10;&#10;🌟&#10;全局置换会造成颠簸，局部置换能限制系统颠簸，但是也会增加进程的有效访问时间，因此应该给进程足够的帧以防止颠簸&#10;&#10;局部性假设">
    <outline text="工作集" _note="工作集理论是在1968年由Denning提出来的。它正是基于局部的假设。&#10;&#10;基本思想：&#10;&#10;&gt; 根据程序的局部性原理，进程在一段时间内总是集中访问一些页面(活跃页面).&#10;&gt;&#10;&gt; 如果分配给一个进程的物理块数太少了，使该进程的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生缺页&#10;&gt;&#10;&gt; 如果能为进程提供与活跃页面数相等的物理块数，则可减少缺页中断次数&#10;&#10;工作集窗口（Δ）是指对于给定的访问序列选取定长的区间，落在工作集窗口中的页面集合称为工作集&#10;&#10;正确选择工作集窗口（Δ）的大小，对存储器的有效利用和系统吞吐量的提高，都将产生重要的影响。&#10;&#10;![](C:\Users\易俊泉\AppData\Roaming\Typora\typora-user-images\image-20211109175844500.png)&#10;&#10;工作集合精确度与Δ的选择有关。&#10;&#10;&gt; 如果Δ 太小，则不能包含整个局部&#10;&gt;&#10;&gt; 如果Δ 太大，则可能包含多个局部&#10;&gt;&#10;&gt; 如果Δ 为无限大，则工作集合就是进程执行所需的所有页的集合&#10;&#10;具体实现：&#10;&#10;&gt; OS跟踪每个进程的工作集，并为其分配大于其工作集的物理块数。&#10;&gt;&#10;&gt; 如果还有空闲物理块，则可启动另外的进程。&#10;&gt;&#10;&gt; 如果所有进程的工作集之和超过了可用物理块的总数，则OS会选择暂停一个进程，该进程被换出，所释放的物理块可分配给其他进程。&#10;&#10;其困难在于如何跟踪工作集合（一般采用定时器中断和引用位实现）">
    </outline>
    <outline text="控制缺页频率" _note="工作集理论可用于预调页，用于防止颠簸，但不够灵活&#10;&#10;一种更加直接的防止颠簸的方法是**控制缺页频率**（ Page-Fault Frequency&#10;）：&#10;&#10;颠簸具有较高的缺页率，所以通过控制缺页频率，可以有效地防止颠簸的发生。&#10;&#10;&gt; 如果缺页率太低，回收一些进程的页框&#10;&gt;&#10;&gt; 如果缺页率太高，就分给进程一些页框">
    </outline>
  </outline>
  <outline text="10.8 其他考虑" _note="目前页大小由系统决定&#10;&#10;&gt; 页面大，则内碎片大&#10;&gt;&#10;&gt; 页面小，则页表占用的空间大&#10;&gt;&#10;&gt; I/O&#10;&gt; overhead（I/O开销）磁盘I/O时间中传输时间和数据量有关系，但它占的比例很小，而寻道时间和旋转延迟时间占了很大的比例。所以页面尺寸比较大会有利于减少磁盘I/O时间。&#10;&gt;&#10;&gt; 减少I/O及内存的占用：要求页面尺寸小&#10;&gt; ，采用小页，总的I/O就会降低，因为小页能够更精确的匹配局部&#10;&gt;&#10;&gt; 减少缺页率：要求页面尺寸大&#10;&gt;&#10;&gt; 总的趋势：**页面尺寸越来越大，这是由于CPU速度和内存容量的增长超过了磁盘速度的加快**&#10;&#10;I/O互锁&#10;&#10;&gt; 在请求页面调度时，允许某些页锁在内存中&#10;&gt;&#10;&gt; 当用户内存有I/O操作时">
  </outline>
  <outline text="">
  </outline>
</outline>
  </body>
</opml>
